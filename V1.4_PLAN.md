# Voice Plant App v1.4 改修計画書

**目標:** 演出強化・ゲームフロー改善・UI/UX向上

## 📋 改修要件まとめ

### 1. オープニング画面追加
- **動画再生機能**（オプション、ムービーモードON/OFF）
- Startボタンまでの導線改善
- ブランディング・世界観の確立

### 2. Start演出強化
- **ロード演出**（緊張感・期待感）
- **演出メッセージ**："大きな声で想いを伝えろ！"
- **カウントダウン演出**（3, 2, 1, START!）

### 3. 成長システム改善（重要）
**現行（v1.3）:**
- 瞬間音量で高さ決定
- リアルタイムに伸び縮み

**v1.4新システム:**
- **MAX到達後、声を伸ばすと成長**
- **持続力が重要**（瞬発力 → 継続力）
- 微調整可能な難易度

### 4. ゲームフロー改善（重要）
**新フロー:**
```
Start
  ↓
カウントダウン（3秒）
  ↓
音量待機（一定Volume超えるまで）
  ↓
チャレンジ開始（成長開始）
  ↓
  ├─ 目標達成 → 突破演出（その場）
  └─ 未達成
  ↓
Volume下降待ち（一定以下になるまで）
  ↓
結果判定
  ├─ Clear!（達成済み）
  └─ Game Over（未達成）
```

### 5. 結果演出追加
- **Clearムービー**（勝利演出、オプション）
- **GameOverムービー**（敗北演出、オプション）
- ムービーモードON/OFF切替

### 6. デシベル表示
- **Canvas内描画**（Visualizer中央）
- リアルタイム数値更新
- 視認性の高いフォント

### 7. 効果音システム
- **ボタンクリック音**
- **カウントダウン音**（3, 2, 1, START!）
- **目標達成音**（突破時）
- **結果発表音**（Clear/GameOver）

---

## 🏗️ アーキテクチャ設計

### モジュール構成（新規追加）

```
src/
├── scenes/                      # シーンシステム（新規）
│   ├── SceneManager.ts          # シーン切り替え管理
│   ├── OpeningScene.ts          # オープニング画面
│   ├── CountdownScene.ts        # カウントダウン演出
│   ├── GameScene.ts             # ゲームプレイ（既存統合）
│   └── ResultScene.ts           # 結果発表
│
├── systems/                     # ゲームシステム（新規）
│   ├── GrowthSystem.ts          # 成長システム（MAX後の持続型）
│   ├── GameFlowController.ts   # ゲームフロー制御
│   └── VolumeThresholdDetector.ts # Volume閾値検出
│
├── assets/                      # アセット管理（新規）
│   ├── sounds/                  # 効果音
│   │   ├── SoundManager.ts      # 音声再生管理
│   │   ├── button-click.mp3
│   │   ├── countdown-3.mp3
│   │   ├── countdown-2.mp3
│   │   ├── countdown-1.mp3
│   │   ├── countdown-start.mp3
│   │   ├── goal-reached.mp3
│   │   └── result.mp3
│   │
│   └── videos/                  # ムービー（オプション）
│       ├── VideoPlayer.ts       # 動画再生管理
│       ├── opening.mp4          # オープニング
│       ├── clear.mp4            # クリア演出
│       └── gameover.mp4         # ゲームオーバー
│
├── ui/                          # UI コンポーネント（新規）
│   ├── MessageDisplay.ts        # メッセージ表示
│   ├── CountdownDisplay.ts      # カウントダウン表示
│   ├── DecibelDisplay.ts        # デシベル表示（Canvas内）
│   └── SettingsPanel.ts         # 設定パネル（ムービーON/OFF等）
│
└── types.ts                     # 型定義拡張
    ├── GameState型追加          # 'opening' | 'countdown' | 'waiting' | 'playing' | 'goalReached' | 'result'
    └── SceneType型追加          # シーン識別
```

---

## 📐 詳細設計

### 1. シーンシステム

#### SceneManager.ts
```typescript
export type SceneType = 'opening' | 'countdown' | 'game' | 'result';

export interface IScene {
    enter(): void;           // シーン開始時
    exit(): void;            // シーン終了時
    update(): void;          // 毎フレーム更新
    draw(p: p5): void;       // 描画
}

export class SceneManager {
    private currentScene: IScene;
    private scenes: Map<SceneType, IScene>;

    switchTo(sceneType: SceneType): void {
        this.currentScene.exit();
        this.currentScene = this.scenes.get(sceneType)!;
        this.currentScene.enter();
    }
}
```

#### OpeningScene.ts
```typescript
export class OpeningScene implements IScene {
    private videoPlayer?: VideoPlayer;
    private skipButton: HTMLButtonElement;

    enter(): void {
        if (settings.movieMode) {
            this.videoPlayer.play('opening');
        }
        // "大きな声で想いを伝えろ！" メッセージ表示
        this.showMessage();
    }

    draw(p: p5): void {
        // ロゴ、タイトル、Startボタン描画
    }
}
```

#### CountdownScene.ts
```typescript
export class CountdownScene implements IScene {
    private countdown: number = 3;
    private soundManager: SoundManager;

    enter(): void {
        this.startCountdown();
    }

    private startCountdown(): void {
        const interval = setInterval(() => {
            this.soundManager.play(`countdown-${this.countdown}`);
            this.countdown--;

            if (this.countdown === 0) {
                clearInterval(interval);
                this.soundManager.play('countdown-start');
                // GameSceneへ遷移
                sceneManager.switchTo('game');
            }
        }, 1000);
    }

    draw(p: p5): void {
        // カウントダウン数字を大きく表示
        p.textSize(120);
        p.text(this.countdown, p.width/2, p.height/2);
    }
}
```

### 2. 成長システム改善

#### GrowthSystem.ts（新規）
```typescript
export class GrowthSystem {
    private maxVolume: number = 0;          // セッション中の最大音量
    private sustainedFrames: number = 0;    // MAX維持フレーム数
    private currentHeight: number = 0;
    private growthRate: number = 2.0;       // 成長速度（調整可能）

    update(volume: number): void {
        // MAX更新
        if (volume > this.maxVolume) {
            this.maxVolume = volume;
        }

        // MAX到達判定（95%以上をMAXとみなす）
        const isAtMax = volume >= this.maxVolume * 0.95;

        if (isAtMax) {
            // MAX維持中 → 成長
            this.sustainedFrames++;
            this.currentHeight += this.growthRate;
            this.currentHeight = Math.min(this.currentHeight, 400); // 上限
        } else {
            // MAX未達 → 成長停止（減衰なし）
            this.sustainedFrames = 0;
        }
    }

    reset(): void {
        this.maxVolume = 0;
        this.sustainedFrames = 0;
        this.currentHeight = 0;
    }

    getCurrentHeight(): number {
        return this.currentHeight;
    }

    getSustainedTime(): number {
        return this.sustainedFrames / 60; // 秒単位
    }
}
```

### 3. ゲームフロー改善

#### GameFlowController.ts（新規）
```typescript
export type GameState =
    | 'opening'        // オープニング
    | 'countdown'      // カウントダウン
    | 'waiting'        // 音量待機（閾値超えるまで）
    | 'playing'        // プレイ中
    | 'goalReached'    // 目標達成（継続中）
    | 'result';        // 結果発表

export class GameFlowController {
    private state: GameState = 'opening';
    private volumeThreshold: number = 0.3;  // 開始閾値
    private endThreshold: number = 0.1;     // 終了閾値
    private goalReached: boolean = false;

    update(volume: number, currentHeight: number, goalHeight: number): void {
        switch (this.state) {
            case 'waiting':
                // 音量が閾値を超えたらプレイ開始
                if (volume > this.volumeThreshold) {
                    this.transitionTo('playing');
                    this.onPlayStart();
                }
                break;

            case 'playing':
                // 目標達成チェック
                if (!this.goalReached && currentHeight >= goalHeight) {
                    this.goalReached = true;
                    this.onGoalReached();  // 突破演出
                    // 状態は'playing'のまま（音量下降待ち）
                }

                // 音量下降チェック
                if (volume < this.endThreshold) {
                    this.transitionTo('result');
                    this.onResult(this.goalReached);
                }
                break;
        }
    }

    private onGoalReached(): void {
        soundManager.play('goal-reached');
        messageDisplay.show('突破！！');
        // 粒子バースト等の演出
    }

    private onResult(cleared: boolean): void {
        soundManager.play('result');
        sceneManager.switchTo('result');
        // ResultSceneにクリア状態を渡す
    }

    transitionTo(newState: GameState): void {
        console.log(`GameState: ${this.state} -> ${newState}`);
        this.state = newState;
    }

    getState(): GameState {
        return this.state;
    }

    reset(): void {
        this.state = 'waiting';
        this.goalReached = false;
    }
}
```

### 4. デシベル表示

#### DecibelDisplay.ts（新規）
```typescript
export class DecibelDisplay {
    private volume: number = 0;

    update(volume: number): void {
        this.volume = volume;
    }

    draw(p: p5): void {
        // Canvas中央（Visualizerの中）に描画
        p.push();
        p.textAlign(p.CENTER, p.CENTER);
        p.textSize(48);
        p.fill(0, 255, 0, 200);  // 半透明の緑
        p.stroke(0, 0, 0, 150);
        p.strokeWeight(3);

        // デシベル換算（仮: 0-1 → 0-100dB）
        const db = Math.round(this.volume * 100);
        p.text(`${db} dB`, p.width / 2, p.height / 2);

        p.pop();
    }
}
```

### 5. 効果音システム

#### SoundManager.ts（新規）
```typescript
export type SoundType =
    | 'button-click'
    | 'countdown-3'
    | 'countdown-2'
    | 'countdown-1'
    | 'countdown-start'
    | 'goal-reached'
    | 'result';

export class SoundManager {
    private sounds: Map<SoundType, HTMLAudioElement> = new Map();
    private enabled: boolean = true;

    constructor() {
        this.loadSounds();
    }

    private loadSounds(): void {
        const soundFiles: Record<SoundType, string> = {
            'button-click': 'assets/sounds/button-click.mp3',
            'countdown-3': 'assets/sounds/countdown-3.mp3',
            'countdown-2': 'assets/sounds/countdown-2.mp3',
            'countdown-1': 'assets/sounds/countdown-1.mp3',
            'countdown-start': 'assets/sounds/countdown-start.mp3',
            'goal-reached': 'assets/sounds/goal-reached.mp3',
            'result': 'assets/sounds/result.mp3'
        };

        Object.entries(soundFiles).forEach(([key, path]) => {
            const audio = new Audio(path);
            audio.preload = 'auto';
            this.sounds.set(key as SoundType, audio);
        });
    }

    play(type: SoundType): void {
        if (!this.enabled) return;

        const sound = this.sounds.get(type);
        if (sound) {
            sound.currentTime = 0;  // 頭出し
            sound.play().catch(err => console.warn('Sound play failed:', err));
        }
    }

    setEnabled(enabled: boolean): void {
        this.enabled = enabled;
    }
}
```

### 6. ムービーシステム

#### VideoPlayer.ts（新規）
```typescript
export type VideoType = 'opening' | 'clear' | 'gameover';

export class VideoPlayer {
    private videos: Map<VideoType, HTMLVideoElement> = new Map();
    private currentVideo?: HTMLVideoElement;
    private onComplete?: () => void;

    constructor() {
        this.loadVideos();
    }

    private loadVideos(): void {
        const videoFiles: Record<VideoType, string> = {
            'opening': 'assets/videos/opening.mp4',
            'clear': 'assets/videos/clear.mp4',
            'gameover': 'assets/videos/gameover.mp4'
        };

        Object.entries(videoFiles).forEach(([key, path]) => {
            const video = document.createElement('video');
            video.src = path;
            video.preload = 'auto';
            video.style.display = 'none';
            document.body.appendChild(video);
            this.videos.set(key as VideoType, video);
        });
    }

    play(type: VideoType, onComplete?: () => void): void {
        this.currentVideo = this.videos.get(type);
        this.onComplete = onComplete;

        if (this.currentVideo) {
            this.currentVideo.style.display = 'block';
            this.currentVideo.style.position = 'absolute';
            this.currentVideo.style.top = '0';
            this.currentVideo.style.left = '0';
            this.currentVideo.style.width = '100%';
            this.currentVideo.style.height = '100%';
            this.currentVideo.style.zIndex = '1000';

            this.currentVideo.onended = () => {
                this.stop();
                if (this.onComplete) this.onComplete();
            };

            this.currentVideo.play();
        }
    }

    stop(): void {
        if (this.currentVideo) {
            this.currentVideo.pause();
            this.currentVideo.currentTime = 0;
            this.currentVideo.style.display = 'none';
        }
    }
}
```

---

## 📊 実装優先度

### Phase A: ゲームフロー改善（最優先）
**期間:** 2-3日
**理由:** ゲーム体験の根幹、他の演出より重要

- [ ] A-1. GameFlowController実装
- [ ] A-2. GrowthSystem実装（MAX後の持続型）
- [ ] A-3. VolumeThresholdDetector実装
- [ ] A-4. PlantView/FractalPlantViewに統合
- [ ] A-5. テスト・調整

### Phase B: シーンシステム（中優先）
**期間:** 2-3日
**理由:** 演出の基盤、効果音・ムービーの前提

- [ ] B-1. SceneManager実装
- [ ] B-2. OpeningScene実装（メッセージ表示）
- [ ] B-3. CountdownScene実装（3,2,1,START!）
- [ ] B-4. ResultScene実装
- [ ] B-5. main.tsに統合

### Phase C: 効果音システム（中優先）
**期間:** 1-2日
**理由:** 比較的簡単、体験向上効果大

- [ ] C-1. SoundManager実装
- [ ] C-2. 効果音アセット準備（仮音でOK）
- [ ] C-3. 各シーンに統合
- [ ] C-4. ON/OFF設定UI追加

### Phase D: デシベル表示（低優先）
**期間:** 0.5日
**理由:** 単純、依存なし

- [ ] D-1. DecibelDisplay実装
- [ ] D-2. Visualizer統合
- [ ] D-3. フォント・色調整

### Phase E: ムービーシステム（オプション）
**期間:** 1-2日
**理由:** オプション機能、リソース次第

- [ ] E-1. VideoPlayer実装
- [ ] E-2. 動画アセット準備（※要相談）
- [ ] E-3. 各シーンに統合
- [ ] E-4. ON/OFF設定UI追加

---

## 🎨 アセット要件

### 効果音（7種類）
| ファイル名 | 用途 | 長さ | 音質要件 |
|-----------|------|------|---------|
| button-click.mp3 | ボタンクリック | 0.1秒 | 軽快、短い |
| countdown-3.mp3 | カウント3 | 0.5秒 | 低音、緊張感 |
| countdown-2.mp3 | カウント2 | 0.5秒 | 中音、緊張感↑ |
| countdown-1.mp3 | カウント1 | 0.5秒 | 高音、緊張感↑↑ |
| countdown-start.mp3 | START! | 1.0秒 | 爆発的、鋭い |
| goal-reached.mp3 | 目標達成 | 1.5秒 | 華やか、勝利感 |
| result.mp3 | 結果発表 | 2.0秒 | ドラマティック |

**仮音源:** Web Audio APIで生成可能（オシレーター）

### ムービー（3種類、オプション）
| ファイル名 | 用途 | 長さ | 解像度 |
|-----------|------|------|--------|
| opening.mp4 | オープニング | 5-10秒 | 800x600 |
| clear.mp4 | クリア演出 | 3-5秒 | 800x600 |
| gameover.mp4 | ゲームオーバー | 3-5秒 | 800x600 |

**代替案:** ムービーなしでも動作（CSS/Canvas演出で代用可）

---

## 🔧 設定UI拡張

### SettingsPanel.ts（新規）
```typescript
export interface GameSettings {
    movieMode: boolean;      // ムービー再生ON/OFF
    soundEnabled: boolean;   // 効果音ON/OFF
    growthRate: number;      // 成長速度（0.5-2.0）
    volumeThreshold: number; // 開始閾値（0.2-0.5）
}

export class SettingsPanel {
    private settings: GameSettings = {
        movieMode: false,
        soundEnabled: true,
        growthRate: 1.0,
        volumeThreshold: 0.3
    };

    // 設定保存（localStorage）
    save(): void {
        localStorage.setItem('voicePlantSettings', JSON.stringify(this.settings));
    }

    // 設定読み込み
    load(): void {
        const saved = localStorage.getItem('voicePlantSettings');
        if (saved) {
            this.settings = JSON.parse(saved);
        }
    }
}
```

---

## 📖 ドキュメント管理

### 新規ドキュメント
1. **ASSETS.md** - アセット管理（効果音・動画のパス、ライセンス）
2. **SCENES.md** - シーンシステム仕様
3. **GAMEFLOW.md** - ゲームフロー詳細設計

### 更新ドキュメント
1. **ARCHITECTURE.md** - v1.4セクション追加
2. **README.md** - v1.4新機能追記
3. **toDo.md** - Phase A-E追加

---

## ⚠️ 注意事項・制約

### ブラウザ互換性
- **動画再生:** Safari/iOS制約あり（自動再生不可、ユーザー操作必要）
- **効果音:** Web Audio API必須（Chrome/Edge推奨）
- **localStorage:** プライベートモードで無効

### パフォーマンス
- **動画再生中:** Canvas描画を一時停止（GPU競合回避）
- **効果音:** preload必須（初回遅延回避）

### リソース
- **動画ファイルサイズ:** 各5MB以下推奨（読み込み時間）
- **効果音ファイルサイズ:** 各100KB以下推奨

---

## 🚀 次のステップ

1. **Phase A実装開始**（ゲームフロー改善）
2. **仮効果音生成**（Web Audio APIオシレーター）
3. **テストプレイ・調整**
4. **Phase B以降を順次実装**

これで改修計画書は完成です。次にASSETS.mdを作成しますか？
